{"meta":{"title":"久铭的空间","subtitle":"一个大男孩","description":"青青子衿，悠悠我心","author":"JiuMingZhu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","text":"404 ! function() { function a(a, b) { return (/string|function/.test(typeof b) ? h : g)(a, b) } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a } function c(a) { return l[a] } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c) } function e(a, b) { if (m(a)) for (var c = 0, d = a.length; d > c; c++) b.call(a, a[c], c, a); else for (c in a) b.call(a, a[c], c) } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\"); e.match(c);) e = e.replace(c, \"/\"); return e } function g(b, c) { var d = a.get(b) || i({ filename: b, name: \"Render Error\", message: \"Template not found\" }); return c ? d(c) : d } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c) } } var d = j[a] = function(c) { try { return new b(c, a) + \"\" } catch (d) { return i(d)() } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\" }, d } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); else for (var d in a) c += \"\\n\" + a[d] + \"\\n\\n\"; return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b } } var j = a.cache = {}, k = this.String, l = { \"\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"&\": \"&#38;\" }, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a) }, n = a.utils = { $helpers: {}, $include: function(a, b, c) { return a = f(c, a), g(a, b) }, $string: b, $escape: d, $each: e }, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")] }, a.helper = function(a, b) { o[a] = b }, \"function\" == typeof define ? define(function() { return a }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), /* * 记住把下面的 homePageName、homePageUrl 改成你想需要的内容 */ d = \"/\", e = \"返回久铭的主页\", f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404，您访问的页面找不回来了，但我们可以一起帮他们回家！ ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') 出生日期：', r += c(j), r += ' 失踪时间：', r += c(l), r += ' 失踪地点：', r += c(m), r += ' 失踪人特征描述：', r += c(n), r += ' 查看详情 分享 腾讯微博 QQ空间 新浪微博 微信 ', p(q, function(a) { r += ' ' }), r += \" \", new k(r) }) }(); 404","path":"404.html"},{"title":"About Me","text":"关于我一个死肥宅，刚毕业一年，正在向着油腻腻的中年大叔发展。 一时心血来潮，然后就选择了这个域名 这个博客是用来记录日常生活的 没办法，突然中二 好像，我确实挺垃圾的 斜杠青年/初级码农/航模飞手/徒步新驴/黑暗料理大师","path":"about/index.html"},{"title":"404 Page Not Found","text":"404 ! function() { function a(a, b) { return (/string|function/.test(typeof b) ? h : g)(a, b) } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a } function c(a) { return l[a] } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c) } function e(a, b) { if (m(a)) for (var c = 0, d = a.length; d > c; c++) b.call(a, a[c], c, a); else for (c in a) b.call(a, a[c], c) } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\"); e.match(c);) e = e.replace(c, \"/\"); return e } function g(b, c) { var d = a.get(b) || i({ filename: b, name: \"Render Error\", message: \"Template not found\" }); return c ? d(c) : d } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c) } } var d = j[a] = function(c) { try { return new b(c, a) + \"\" } catch (d) { return i(d)() } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\" }, d } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); else for (var d in a) c += \"\\n\" + a[d] + \"\\n\\n\"; return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b } } var j = a.cache = {}, k = this.String, l = { \"\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"&\": \"&#38;\" }, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a) }, n = a.utils = { $helpers: {}, $include: function(a, b, c) { return a = f(c, a), g(a, b) }, $string: b, $escape: d, $each: e }, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")] }, a.helper = function(a, b) { o[a] = b }, \"function\" == typeof define ? define(function() { return a }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), /* * 记住把下面的 homePageName、homePageUrl 改成你想需要的内容 */ d = \"/\", e = \"返回久铭的主页\", f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404，您访问的页面找不回来了，但我们可以一起帮他们回家！ ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') 出生日期：', r += c(j), r += ' 失踪时间：', r += c(l), r += ' 失踪地点：', r += c(m), r += ' 失踪人特征描述：', r += c(n), r += ' 查看详情 分享 腾讯微博 QQ空间 新浪微博 微信 ', p(q, function(a) { r += ' ' }), r += \" \", new k(r) }) }(); 404","path":"404/index.html"}],"posts":[{"title":"ABL中的Create","text":"这里的Create，并不是创建表的意思，而是创建一条记录CREATE statement Creates a record in a table, sets all the fields in the record to their default initial values, and moves a copy of the record to the record buffer.","path":"2019/08/05/ABL中的Create/"},{"title":"ABL中的CHARACTER","text":"该来的迟早要来，终于开始了对progress数据库的学习 progress数据库ABL中的CHARACTER对于CHARACTER的困惑，源自于以下两种写法。 MESSAGE “input” UPDATE testArry FORMAT “x(60)”.这句的意思是弹窗，这个弹窗是用于接收一个最大长度为60的字符串，并将其返回。 这就引发了一个问题：An array was specified in an expression, on the right-hand side of an assignment, or as a parameter when no array is appropriate or expected.意思就是，你不能把一个字符串类型赋值给一个Array类型的变量（no array is appropriate or expected.） 那么问题来了，Str是string，testArry不是string （这里的Str命名不符合驼峰法，打50大板→_→）这就让人费解了啊，ABL里面CHARACTER到底是什么类型的值呢？？？ 查资料ing…找到了一篇文章：Data types CHARACTER data consists of numbers, letters, and special characters. 由此可见，在ABL中，CHARACTER data 基本符合我们在传统语言中对char的理解继续试验： 1234567891011DEFINE VARIABLE Str AS CHARACTER NO-UNDO.Str = &apos;a&apos;.MESSAGE Str.DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT.EXTENT(testArry) = 4.testArry[1] = &apos;a&apos;.MESSAGE testArry[1].testArry[1] = &quot;a&quot;.MESSAGE testArry[1].testArry[1] = &quot;abc&quot;.MESSAGE testArry[1]. 输出值如下： 1234aaaabc 那么问题来了，CHARACTER 到底是string 还是char？（写strong type 语言的人伤不起Orz.）Debug走起！ emmm，这边双引号，是不是表示此时的Str是不是string类型？回到Data types找资料 CHARACTER的默认值是””,再看一眼从ABL到.net 的类型映射 到这里，基本可以把CHARACTER当做string类型去理解了 那么问题来了，Str是string，testArry不是string （这里的Str命名不符合驼峰法，打50大板→_→） 搞明白了CHARACTER的类型，这个问题依旧还再哪儿。看之前写的测试代码 1234567891011DEFINE VARIABLE Str AS CHARACTER NO-UNDO.Str = &apos;a&apos;.MESSAGE Str.DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT.EXTENT(testArry) = 4.testArry[1] = &apos;a&apos;.MESSAGE testArry[1].testArry[1] = &quot;a&quot;.MESSAGE testArry[1].testArry[1] = &quot;abc&quot;.MESSAGE testArry[1]. 输出值如下： 1234aaaabc 这里有个attribute EXTENT ，这个属性是用来标记一个变量是否应该被当做数组来处理。 EXTENT attributeThe number of elements in an array field.Data type: INTEGERAccess: Read-onlyApplies to: Buffer-field object handleNote: The EXTENT attribute corresponds to the EXTENT function. 所以，之所以会有此前的问题，是因为我在声明变量的时候给这2个变量分配了不同的类型。使用 12MESSAGE &quot;input&quot; UPDATE testArry[1] FORMAT &quot;x(60)&quot;.MESSAGE testArry[1]. 以访问数组的方式去访问此时的testArry 就没有问题。对于EXTENT这个attribute，我的理解是：这只是ABL中的一个书写语法加上了EXTENT 的variable就好比C#中加上了[] 的variable 1DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT. &lt;=&gt; 1string[] testArry; 以上に","path":"2019/08/01/ABL中的CHARACTER/"},{"title":"CSarp Point of Instance","text":"此前我一直认为C#里面的应用类型的传参都是传递引用，直到我今天遇到了这样的一个函数 1234static void ChangeProduct(Product product)&#123; product = new Product();&#125; 按照我之前的理解：调用完这个方法后，product所指向的对象应该就是新的实例了 然而，实际测试了下，并不是。 注意我自己说的话：product所指向的对象 没错，product所指的对象，那么这个product是什么，它并不是对象，而是一个值类型，有点类似C++的指针，指针本身是个指针类型，因此才会有了指向指针的指针，所以ChangeProduct 对product的改变并不会影响到调用者的product。为此，写了个demo进行了测试 12345678910111213141516171819202122232425262728293031class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); Product product = new Product() &#123; Category = &quot;Category&quot; &#125;; ChangeProduct(product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); ChangeProductCategory(product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); ChangeProductByRef(ref product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); Console.WriteLine($&quot;product,s type is &#123;product.GetType()&#125;&quot;); &#125; static void ChangeProductByRef(ref Product product) &#123; product = new Product(); &#125; static void ChangeProduct(Product product) &#123; product = new Product(); &#125; static void ChangeProductCategory(Product product) &#123; product.Category = &quot;Category has been changed&quot;; &#125;&#125;class Product&#123; public string Category &#123; get; set; &#125;&#125; out put 123456789Hello World!product,s category is Categoryproduct,s category is Category has been changedproduct,s category isproduct,s type is Test.ProductC:\\Program Files\\dotnet\\dotnet.exe (process 26460) exited with code 0.To automatically close the console when debugging stops, enable Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.Press any key to close this window . . . 这么看来，ref 此时起到的作用关键字更像是指向指针的指针以后不能单纯的认为方法的参数如果是对象，就一定会改变对象了","path":"2019/07/25/CSarpPointofInstance/"},{"title":"七月上","text":"作曲 : Jam作词 : Jam我化尘埃飞扬，追寻赤裸逆翔奔去七月刑场，时间烧灼滚烫回忆撕毁臆想，路上行走匆忙难能可贵世上，散播留香磁场我欲乘风破浪，踏遍黄沙海洋 与其误会一场，也要不负勇往我愿你是个谎，从未出现南墙笑是神的伪装，笑是强忍的伤就让我走向你，走向你的床就让我看见你，看见你的伤我想你就站在，站在大漠边疆我想你就站在，站在七月上我化尘埃飞扬，追寻赤裸逆翔奔去七月刑场，时间烧灼滚烫回忆撕毁臆想，路上行走匆忙难能可贵世上，散播留香磁场我欲乘风破浪，踏遍黄沙海洋与其误会一场，也要不负勇往我愿你是个谎，从未出现南墙笑是神的伪装，笑是强忍的伤就让我走向你，走向你的窗就让我看见你，看见你的伤我想你就站在，站在大漠边疆我想你就站在，站在七月上","path":"2016/11/12/七月上/"},{"title":"Hexo测试——图片的保存以及引用","text":"临近毕业，要好好准备一下相关知识成果，准备投递简历实习了。之前一直想着写带图片的博客，但是好像Hexo上markdown写作引用图片不想平常的博客只是简单的复制粘贴，今天就研究一下。省的日后写起来又要回头查找资料。 示例：引用图片 之前Google到的好多类似于使用第三方云储存的方案，不知道是不是以前的Hexo2对应的方法，现在正如官方文档中所说，使用 插件可以方便的引用图片。 具体原因是因为现在Hexo3在本地的config.yml中有了post_asset_folder:true这个选项，将其设置成true后在你新建文章后会在_post目录生成对应的资源文件夹。 官方文档如下：","path":"2016/11/08/Hexo测试——图片的保存以及引用/"}]}