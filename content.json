{"meta":{"title":"久铭的空间","subtitle":"一个大男孩","description":"青青子衿，悠悠我心","author":"JiuMingZhu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","text":"404 ! function() { function a(a, b) { return (/string|function/.test(typeof b) ? h : g)(a, b) } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a } function c(a) { return l[a] } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c) } function e(a, b) { if (m(a)) for (var c = 0, d = a.length; d > c; c++) b.call(a, a[c], c, a); else for (c in a) b.call(a, a[c], c) } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\"); e.match(c);) e = e.replace(c, \"/\"); return e } function g(b, c) { var d = a.get(b) || i({ filename: b, name: \"Render Error\", message: \"Template not found\" }); return c ? d(c) : d } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c) } } var d = j[a] = function(c) { try { return new b(c, a) + \"\" } catch (d) { return i(d)() } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\" }, d } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); else for (var d in a) c += \"\\n\" + a[d] + \"\\n\\n\"; return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b } } var j = a.cache = {}, k = this.String, l = { \"\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"&\": \"&#38;\" }, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a) }, n = a.utils = { $helpers: {}, $include: function(a, b, c) { return a = f(c, a), g(a, b) }, $string: b, $escape: d, $each: e }, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")] }, a.helper = function(a, b) { o[a] = b }, \"function\" == typeof define ? define(function() { return a }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), /* * 记住把下面的 homePageName、homePageUrl 改成你想需要的内容 */ d = \"/\", e = \"返回久铭的主页\", f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404，您访问的页面找不回来了，但我们可以一起帮他们回家！ ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') 出生日期：', r += c(j), r += ' 失踪时间：', r += c(l), r += ' 失踪地点：', r += c(m), r += ' 失踪人特征描述：', r += c(n), r += ' 查看详情 分享 腾讯微博 QQ空间 新浪微博 微信 ', p(q, function(a) { r += ' ' }), r += \" \", new k(r) }) }(); 404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/assets/hibiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":350},\"mobile\":{\"show\":true},\"log\":false});","path":"404.html"},{"title":"About Me","text":"关于我一个死肥宅，刚毕业一年，正在向着油腻腻的中年大叔发展。 一时心血来潮，然后就选择了这个域名 这个博客是用来记录日常生活的 没办法，突然中二 好像，我确实挺垃圾的 斜杠青年/初级码农/航模飞手/徒步新驴/黑暗料理大师","path":"about/index.html"},{"title":"404 Page Not Found","text":"404 ! function() { function a(a, b) { return (/string|function/.test(typeof b) ? h : g)(a, b) } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a } function c(a) { return l[a] } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c) } function e(a, b) { if (m(a)) for (var c = 0, d = a.length; d > c; c++) b.call(a, a[c], c, a); else for (c in a) b.call(a, a[c], c) } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\"); e.match(c);) e = e.replace(c, \"/\"); return e } function g(b, c) { var d = a.get(b) || i({ filename: b, name: \"Render Error\", message: \"Template not found\" }); return c ? d(c) : d } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c) } } var d = j[a] = function(c) { try { return new b(c, a) + \"\" } catch (d) { return i(d)() } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\" }, d } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); else for (var d in a) c += \"\\n\" + a[d] + \"\\n\\n\"; return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b } } var j = a.cache = {}, k = this.String, l = { \"\": \"&#62;\", '\"': \"&#34;\", \"'\": \"&#39;\", \"&\": \"&#38;\" }, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a) }, n = a.utils = { $helpers: {}, $include: function(a, b, c) { return a = f(c, a), g(a, b) }, $string: b, $escape: d, $each: e }, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")] }, a.helper = function(a, b) { o[a] = b }, \"function\" == typeof define ? define(function() { return a }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), /* * 记住把下面的 homePageName、homePageUrl 改成你想需要的内容 */ d = \"/\", e = \"返回久铭的主页\", f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404，您访问的页面找不回来了，但我们可以一起帮他们回家！ ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') 出生日期：', r += c(j), r += ' 失踪时间：', r += c(l), r += ' 失踪地点：', r += c(m), r += ' 失踪人特征描述：', r += c(n), r += ' 查看详情 分享 腾讯微博 QQ空间 新浪微博 微信 ', p(q, function(a) { r += ' ' }), r += \" \", new k(r) }) }(); 404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/assets/hibiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":350},\"mobile\":{\"show\":true},\"log\":false});","path":"404/index.html"}],"posts":[{"title":"ABL中的DynamicTempTable","text":"DynamicTempTableQuery可以有动态的，temp-table也可以有。 DynamicTempTable的一般格式123456789101112131415161718192021222324252627/* declare handles */DEFINE VARIABLE tth AS HANDLE NO-UNDO. //define a temp-table handleDEFINE VARIABLE tthndl AS HANDLE NO-UNDO. //define a temp-table buffer handleDEFINE VARIABLE qh AS HANDLE NO-UNDO. define a dynamic query handle/* Create an empty, undefined temp-table */CREATE TEMP-TABLE tth./* Add fields to the temp-table */tth:ADD-NEW-FIELD(&quot;FieldName&quot;,&quot;datatype&quot;).tth:ADD-NEW-FIELD(&quot;studentId&quot;, &quot;character&quot;)./* Signal that the temp-table definition is complete and assign it the name &quot;ttS tudent&quot; */tth:TEMP-TABLE-PREPARE(&quot;temp-table name&quot;)./* Create a dynamic query */CREATE QUERY qh./* dynamic query settings */qh:SET-BUFFERS(tthndl).qh:QUERY-PREPARE(&quot;query string&quot;).qh:QUERY-OPEN().qh:GET-FIRST().REPEAT WHILE NOT qh:QUERY-OFF-END: /* options on this record */ qh:GET-NEXT().END.qh:QUERY-CLOSE().DELETE OBJECT qh. 举个栗子1234567891011121314151617181920212223242526272829303132/* declare a temp-table */DEFINE VARIABLE tth AS HANDLE NO-UNDO.DEFINE VARIABLE tthndl AS HANDLE NO-UNDO./* Create an empty, undefined temp-table */CREATE TEMP-TABLE tth./* Add fields to the temp-table */tth:ADD-NEW-FIELD(&quot;studentName&quot;,&quot;character&quot;).tth:ADD-NEW-FIELD(&quot;studentNo&quot;,&quot;integer&quot;).tth:ADD-NEW-FIELD(&quot;studentId&quot;, &quot;character&quot;)./* Signal that the temp-table definition is complete and assign it the name &quot;ttS tudent&quot; */tth:TEMP-TABLE-PREPARE(&quot;ttStudent&quot;)./* throw errorr after temp-table prepared *///tth:ADD-NEW-FIELD(&quot;studentScore&quot;, &quot;integer&quot;)./* Get the buffer-handle for the temp-table */tthndl = tth:DEFAULT-BUFFER-HANDLE. //DEFAULT-BUFFER-HANDLE returns a buffer of temptable/* create a record */tthndl:BUFFER-CREATE().tthndl:BUFFER-FIELD(&quot;studentName&quot;):BUFFER-VALUE = &quot;August&quot;.tthndl:BUFFER-FIELD(&quot;studentNo&quot;):BUFFER-VALUE = &quot;0001&quot;.tthndl:BUFFER-FIELD(&quot;studentId&quot;):BUFFER-VALUE = &quot;0001&quot;.tthndl:BUFFER-RELEASE()./* or can use simple syntax */tthndl:BUFFER-CREATE().tthndl::studentName = &quot;Chen&quot;.tthndl::studentNo = &quot;0002&quot;.tthndl::studentId = &quot;0002&quot;.tthndl:BUFFER-RELEASE(). 这边有个语法糖，可以用::代替冗长的BUFFER-FIELD(“XXX”):BUFFER-VALUE 1234/* dynamic temp-table need dynamic query *///FOR EACH tth// DISP studentName studentNo studentId.//END. 这边不能用静态查询，因为tth和tthndl只是temp-table 的handle 和 buffer handle，AVM没有办法知道此时此刻的handle指向的是哪个temp-table.tth:TEMP-TABLE-PREPARE(&quot;ttStudent&quot;).执行完后，就不能去改变field了，这句相当于告诉AVM此时的temp-table已经准备完毕。但是我依旧可以再执行以下步骤： 12345678CREATE TEMP-TABLE tth./* Add fields to the temp-table */tth:ADD-NEW-FIELD(&quot;studentName&quot;,&quot;character&quot;).tth:ADD-NEW-FIELD(&quot;studentNo&quot;,&quot;integer&quot;).tth:ADD-NEW-FIELD(&quot;studentId&quot;, &quot;character&quot;)./* Signal that the temp-table definition is complete and assign it the name &quot;ttS tudent&quot; */tth:TEMP-TABLE-PREPARE(&quot;ttStudent&quot;). 即将这个temp-table的指针指向一个新的temp-table，而我可以prepare一个新的tablename。因此，dynamic temp-table只能用dynamic query去查询。 1234567891011121314151617181920/* create a dynamic query */DEFINE VARIABLE qh AS HANDLE NO-UNDO.DEFINE VARIABLE qryStr AS CHARACTER NO-UNDO.qryStr = &quot;FOR EACH ttStudent NO-LOCK&quot;.CREATE QUERY qh.qh:SET-BUFFERS(tthndl).qh:QUERY-PREPARE(qryStr).qh:QUERY-OPEN().qh:GET-FIRST().REPEAT WHILE NOT qh:QUERY-OFF-END:/* DISP qh:GET-BUFFER-HANDLE():BUFFER-FIELD(&quot;studentName&quot;):BUFFER-VALUE *//* qh:GET-BUFFER-HANDLE():BUFFER-FIELD(&quot;studentNo&quot;):BUFFER-VALUE *//* qh:GET-BUFFER-HANDLE():BUFFER-FIELD(&quot;studentId&quot;):BUFFER-VALUE. */ DISP qh:GET-BUFFER-HANDLE(&quot;ttStudent&quot;)::studentName //get ttStudent buffer handle in this query qh:GET-BUFFER-HANDLE()::studentNo qh:GET-BUFFER-HANDLE()::studentId. qh:GET-NEXT().END.qh:QUERY-CLOSE().DELETE OBJECT qh. dynamic query上篇博文写过了，就不多说。语法糖在这里也是可以用的，不过需要注意的就是每次循环都不能忘了写qh:GET-NEXT()否则就死在这里了。。。","path":"2019/10/08/ABL中的DynamicTempTable/"},{"title":"ABL中的DynamicQuery","text":"DynamicQuery当一个proc需要动态根据输入的条件去query或者group，条件分支越多，需要写的query分支就越多，此时就需要动态查询来动态的根据查询条件来组合query语句了。 DynamicQuery的一般格式12345678910111213DEF VAR qh AS HANDLE NO-UNDO.DEF VAR query-string AS CHAR NO-UNDO.CREATE QUERY qh.qh:SET-BUFFERS(BUFFER xxxx HANDLE).ASSIGN qry-str = &quot;xxxxxx&quot;.qh:QUERY-PREPARE(qry-str).qh:QUERY-OPEN.qh:GET-FIRST().REPEAT WHILE NOT qh:QUERY-OFF-END:qh:GET-NEXT().END.qh:QUERY-CLOSE.DELETE OBJECT qh. 咬文嚼字时间到初学一门语言的时候，最难熬不过于熟悉它的语法、特性。不过熟悉之后，写代码就可以骚起来了。——沃兹基硕德 CREATE QUERY statement Creates a dynamic query.handleA variable of type HANDLE that represents the handle of the query object.CREATE-QUERY must be followed by the QUERY-PREPARE( ) and QUERY-OPEN() methods before the query can be run. 没啥好说的，就是固定的语法.看这个说明——“handle of the query object”，这里使用的qh应该可以理解为一个指向query对象实例的指针。在一个query可以被执行前，必须执行QUERY-PREPARE() 和 QUERY-OPEN()方法。 qh:GET-FIRST() Moves a query object’s result list pointer to the first row.Return type: LOGICALGET-FIRST() returns TRUE if the first record in the query is found. If the query is not open or the first record cannot be found (query is empty), the method returns FALSE. If the query object handle is invalid, the method returns the Unknown value (?). 学了ABL的面向对象后再来看这个语法，这尼玛不就是调用实例方法的语法么==顺便说一句：当时还想着如果没找到的话继续执行是不是会报错，现在知道了，GET-FIRST()这个函数是有返回值的，可以根据这个函数的返回值去判断当前这个dynamic query的结果集是否有数据。 REPEAT Begins a block of statements that are processed repeatedly until the block ends in one of several ways. Use an END statement to end a REPEAT block. REPEAT就是一个固定的statement.和Do一样，可以用来做循环。不BB，上代码 123456789DEFINE VARIABLE i AS INTEGER NO-UNDO.DO i = 1 TO 5: MESSAGE &quot;Hit&quot; i.END.i=0.REPEAT i = 1 TO 5: MESSAGE &quot;Hit&quot; i.END. 执行结果为： 12345678910&quot;Hit&quot; 1&quot;Hit&quot; 2&quot;Hit&quot; 3&quot;Hit&quot; 4&quot;Hit&quot; 5&quot;Hit&quot; 1&quot;Hit&quot; 2&quot;Hit&quot; 3&quot;Hit&quot; 4&quot;Hit&quot; 5 →_→，我有一万种方法来写循环。但是，这句话我没看懂： Use a DO statement rather than a REPEAT statement when you loop through each element ofan array. This way the AVM does not create separate subtransactions within atransaction. 反正试验起来DO 和 REPEAT表现不一致就是了，有空问问公司大佬。 qh:GET-NEXT() Moves a query object’s result list pointer ahead one row.GET-NEXT() returns TRUE if the next record in the query is found. If the query is not open or the next record cannot be found (query is empty or the query result list pointer is on the last row), the method returns FALSE. If the query object handle is invalid, the method returns the Unknown value (?). 意思就是把当前的query指针移向结果集的下一行，并返回结果。所以之前的一般格式理论上也可以改为： 1234567891011121314DEF VAR qh AS HANDLE NO-UNDO.DEF VAR query-string AS CHAR NO-UNDO.CREATE QUERY qh.qh:SET-BUFFERS(BUFFER xxxx HANDLE).ASSIGN qry-str = &quot;xxxxxx&quot;.qh:QUERY-PREPARE(qry-str).qh:QUERY-OPEN.qh:GET-FIRST().REPEAT WHILE YES:IF NOT qh:GET-NEXT() THEN LEAVE.END.qh:QUERY-CLOSE.DELETE OBJECT qh. 这边通过 12IF NOT qh:GET-NEXT() THEN LEAVE. 这段代码来控制循环的终结。 qh:QUERY-CLOSE Closes a query object.A QUERY-CLOSE does not invalidate a previous QUERY-PREPARE DELETE OBJECT qh Deletes an object such as a widget, a procedure, a server, a socket, or an instance of aclass. Deleting the object causes all allocated resources associated with the object to bereturned to the system (except when otherwise noted)..NETautomatically calls Dispose( ) on a non-modal form when it is closed,unless the form is shown as a dialog box. .NET simply hides the dialog when it isclosed. However, the AVM calls Dispose( ) by default for dialogs thatinherit from Progress.Windows.Form. The AVM does not do this if the DisposeDialogOnClose property of the form is set to FALSE. This canbe set on a particular instance or globally using the No Dialog Dispose(-nodialogdispose) startup parameter. One use case for not calling Dispose( ) is if you want to re-use the form at a latertime. 以下是对object的描述 The ABL Virtual Machine (AVM) automatically deletes (garbage collects) any class instance that you create with the NEW statement some time after no reference to that object exists in the ABL session. However, you can force any class instance to be deleted immediately by using the DELETE OBJECT statement. For more information on garbage collection for class instances, see the DELETE OBJECT statement reference entry. AVM是有垃圾回收机制的，那么问题来了：为什么query handle需要被释放？可能是因为query对象创建后会始终保持着引用的状态，所以不会被自动回收？","path":"2019/08/09/ABL中的DynamicQuery/"},{"title":"ABL中的Create","text":"这里的Create，并不是创建表的意思，而是创建一条记录CREATE statement Creates a record in a table, sets all the fields in the record to their default initial values, and moves a copy of the record to the record buffer.","path":"2019/08/05/ABL中的Create/"},{"title":"ABL中的CHARACTER","text":"该来的迟早要来，终于开始了对progress数据库的学习 progress数据库ABL中的CHARACTER对于CHARACTER的困惑，源自于以下两种写法。 MESSAGE “input” UPDATE testArry FORMAT “x(60)”.这句的意思是弹窗，这个弹窗是用于接收一个最大长度为60的字符串，并将其返回。 这就引发了一个问题：An array was specified in an expression, on the right-hand side of an assignment, or as a parameter when no array is appropriate or expected.意思就是，你不能把一个字符串类型赋值给一个Array类型的变量（no array is appropriate or expected.） 那么问题来了，Str是string，testArry不是string （这里的Str命名不符合驼峰法，打50大板→_→）这就让人费解了啊，ABL里面CHARACTER到底是什么类型的值呢？？？ 查资料ing…找到了一篇文章：Data types CHARACTER data consists of numbers, letters, and special characters. 由此可见，在ABL中，CHARACTER data 基本符合我们在传统语言中对char的理解继续试验： 1234567891011DEFINE VARIABLE Str AS CHARACTER NO-UNDO.Str = &apos;a&apos;.MESSAGE Str.DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT.EXTENT(testArry) = 4.testArry[1] = &apos;a&apos;.MESSAGE testArry[1].testArry[1] = &quot;a&quot;.MESSAGE testArry[1].testArry[1] = &quot;abc&quot;.MESSAGE testArry[1]. 输出值如下： 1234aaaabc 那么问题来了，CHARACTER 到底是string 还是char？（写strong type 语言的人伤不起Orz.）Debug走起！ emmm，这边双引号，是不是表示此时的Str是不是string类型？回到Data types找资料 CHARACTER的默认值是””,再看一眼从ABL到.net 的类型映射 到这里，基本可以把CHARACTER当做string类型去理解了 那么问题来了，Str是string，testArry不是string （这里的Str命名不符合驼峰法，打50大板→_→） 搞明白了CHARACTER的类型，这个问题依旧还再哪儿。看之前写的测试代码 1234567891011DEFINE VARIABLE Str AS CHARACTER NO-UNDO.Str = &apos;a&apos;.MESSAGE Str.DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT.EXTENT(testArry) = 4.testArry[1] = &apos;a&apos;.MESSAGE testArry[1].testArry[1] = &quot;a&quot;.MESSAGE testArry[1].testArry[1] = &quot;abc&quot;.MESSAGE testArry[1]. 输出值如下： 1234aaaabc 这里有个attribute EXTENT ，这个属性是用来标记一个变量是否应该被当做数组来处理。 EXTENT attributeThe number of elements in an array field.Data type: INTEGERAccess: Read-onlyApplies to: Buffer-field object handleNote: The EXTENT attribute corresponds to the EXTENT function. 所以，之所以会有此前的问题，是因为我在声明变量的时候给这2个变量分配了不同的类型。使用 12MESSAGE &quot;input&quot; UPDATE testArry[1] FORMAT &quot;x(60)&quot;.MESSAGE testArry[1]. 以访问数组的方式去访问此时的testArry 就没有问题。对于EXTENT这个attribute，我的理解是：这只是ABL中的一个书写语法加上了EXTENT 的variable就好比C#中加上了[] 的variable 1DEFINE VARIABLE testArry AS CHARACTER NO-UNDO EXTENT. &lt;=&gt; 1string[] testArry; 以上に","path":"2019/08/01/ABL中的CHARACTER/"},{"title":"CSarp Point of Instance","text":"此前我一直认为C#里面的应用类型的传参都是传递引用，直到我今天遇到了这样的一个函数 1234static void ChangeProduct(Product product)&#123; product = new Product();&#125; 按照我之前的理解：调用完这个方法后，product所指向的对象应该就是新的实例了 然而，实际测试了下，并不是。 注意我自己说的话：product所指向的对象 没错，product所指的对象，那么这个product是什么，它并不是对象，而是一个值类型，有点类似C++的指针，指针本身是个指针类型，因此才会有了指向指针的指针，所以ChangeProduct 对product的改变并不会影响到调用者的product。为此，写了个demo进行了测试 12345678910111213141516171819202122232425262728293031class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); Product product = new Product() &#123; Category = &quot;Category&quot; &#125;; ChangeProduct(product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); ChangeProductCategory(product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); ChangeProductByRef(ref product); Console.WriteLine($&quot;product,s category is &#123;product.Category&#125;&quot;); Console.WriteLine($&quot;product,s type is &#123;product.GetType()&#125;&quot;); &#125; static void ChangeProductByRef(ref Product product) &#123; product = new Product(); &#125; static void ChangeProduct(Product product) &#123; product = new Product(); &#125; static void ChangeProductCategory(Product product) &#123; product.Category = &quot;Category has been changed&quot;; &#125;&#125;class Product&#123; public string Category &#123; get; set; &#125;&#125; out put 123456789Hello World!product,s category is Categoryproduct,s category is Category has been changedproduct,s category isproduct,s type is Test.ProductC:\\Program Files\\dotnet\\dotnet.exe (process 26460) exited with code 0.To automatically close the console when debugging stops, enable Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.Press any key to close this window . . . 这么看来，ref 此时起到的作用关键字更像是指向指针的指针以后不能单纯的认为方法的参数如果是对象，就一定会改变对象了","path":"2019/07/25/CSarpPointofInstance/"},{"title":"七月上","text":"作曲 : Jam作词 : Jam我化尘埃飞扬，追寻赤裸逆翔奔去七月刑场，时间烧灼滚烫回忆撕毁臆想，路上行走匆忙难能可贵世上，散播留香磁场我欲乘风破浪，踏遍黄沙海洋 与其误会一场，也要不负勇往我愿你是个谎，从未出现南墙笑是神的伪装，笑是强忍的伤就让我走向你，走向你的床就让我看见你，看见你的伤我想你就站在，站在大漠边疆我想你就站在，站在七月上我化尘埃飞扬，追寻赤裸逆翔奔去七月刑场，时间烧灼滚烫回忆撕毁臆想，路上行走匆忙难能可贵世上，散播留香磁场我欲乘风破浪，踏遍黄沙海洋与其误会一场，也要不负勇往我愿你是个谎，从未出现南墙笑是神的伪装，笑是强忍的伤就让我走向你，走向你的窗就让我看见你，看见你的伤我想你就站在，站在大漠边疆我想你就站在，站在七月上","path":"2016/11/12/七月上/"},{"title":"Hexo测试——图片的保存以及引用","text":"临近毕业，要好好准备一下相关知识成果，准备投递简历实习了。之前一直想着写带图片的博客，但是好像Hexo上markdown写作引用图片不想平常的博客只是简单的复制粘贴，今天就研究一下。省的日后写起来又要回头查找资料。 示例：引用图片 之前Google到的好多类似于使用第三方云储存的方案，不知道是不是以前的Hexo2对应的方法，现在正如官方文档中所说，使用 插件可以方便的引用图片。 具体原因是因为现在Hexo3在本地的config.yml中有了post_asset_folder:true这个选项，将其设置成true后在你新建文章后会在_post目录生成对应的资源文件夹。 官方文档如下：","path":"2016/11/08/Hexo测试——图片的保存以及引用/"}]}